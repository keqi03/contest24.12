# Generated from NMLC.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\65")
        buf.write("\u00a2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\6\2(\n\2\r\2\16\2)\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\6\3\6")
        buf.write("\3\7\3\7\3\7\5\7D\n\7\3\7\3\7\3\7\3\7\7\7J\n\7\f\7\16")
        buf.write("\7M\13\7\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\tY")
        buf.write("\n\t\3\t\3\t\3\t\3\t\7\t_\n\t\f\t\16\tb\13\t\3\n\3\n\3")
        buf.write("\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\7\13n\n\13\f\13")
        buf.write("\16\13q\13\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\5\f\u0080\n\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r")
        buf.write("\7\r\u0089\n\r\f\r\16\r\u008c\13\r\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\3\17\3\17\3\20\3\20\3\21")
        buf.write("\3\21\3\22\3\22\3\23\3\23\3\23\2\6\f\20\24\30\24\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\30\32\34\36 \"$\2\b\3\2\t\n\3\2")
        buf.write("\f\r\3\2\17#\3\2./\4\2\13\13//\4\2\13\13./\2\u009f\2\'")
        buf.write("\3\2\2\2\4+\3\2\2\2\6\66\3\2\2\2\b8\3\2\2\2\n>\3\2\2\2")
        buf.write("\fC\3\2\2\2\16N\3\2\2\2\20X\3\2\2\2\22c\3\2\2\2\24e\3")
        buf.write("\2\2\2\26\177\3\2\2\2\30\u0081\3\2\2\2\32\u008d\3\2\2")
        buf.write("\2\34\u0097\3\2\2\2\36\u0099\3\2\2\2 \u009b\3\2\2\2\"")
        buf.write("\u009d\3\2\2\2$\u009f\3\2\2\2&(\5\4\3\2\'&\3\2\2\2()\3")
        buf.write("\2\2\2)\'\3\2\2\2)*\3\2\2\2*\3\3\2\2\2+,\5\6\4\2,-\7\3")
        buf.write("\2\2-.\7\4\2\2./\5\b\5\2/\60\7\5\2\2\60\61\7\6\2\2\61")
        buf.write("\62\7\4\2\2\62\63\5\32\16\2\63\64\7\5\2\2\64\65\7\7\2")
        buf.write("\2\65\5\3\2\2\2\66\67\7/\2\2\67\7\3\2\2\289\5\n\6\29:")
        buf.write("\7\b\2\2:;\5\f\7\2;<\7\b\2\2<=\5\20\t\2=\t\3\2\2\2>?\t")
        buf.write("\2\2\2?\13\3\2\2\2@A\b\7\1\2AD\7\13\2\2BD\7/\2\2C@\3\2")
        buf.write("\2\2CB\3\2\2\2DK\3\2\2\2EF\f\5\2\2FG\5\16\b\2GH\5\f\7")
        buf.write("\6HJ\3\2\2\2IE\3\2\2\2JM\3\2\2\2KI\3\2\2\2KL\3\2\2\2L")
        buf.write("\r\3\2\2\2MK\3\2\2\2NO\t\3\2\2O\17\3\2\2\2PQ\b\t\1\2Q")
        buf.write("Y\7\13\2\2RS\5\22\n\2ST\5\24\13\2TY\3\2\2\2UV\7/\2\2V")
        buf.write("W\7\16\2\2WY\7/\2\2XP\3\2\2\2XR\3\2\2\2XU\3\2\2\2Y`\3")
        buf.write("\2\2\2Z[\f\6\2\2[\\\5\16\b\2\\]\5\20\t\7]_\3\2\2\2^Z\3")
        buf.write("\2\2\2_b\3\2\2\2`^\3\2\2\2`a\3\2\2\2a\21\3\2\2\2b`\3\2")
        buf.write("\2\2cd\t\4\2\2d\23\3\2\2\2ef\b\13\1\2fg\5\26\f\2gh\5\30")
        buf.write("\r\2ho\3\2\2\2ij\f\4\2\2jk\5\16\b\2kl\5\24\13\5ln\3\2")
        buf.write("\2\2mi\3\2\2\2nq\3\2\2\2om\3\2\2\2op\3\2\2\2p\25\3\2\2")
        buf.write("\2qo\3\2\2\2r\u0080\7$\2\2s\u0080\7%\2\2t\u0080\7&\2\2")
        buf.write("u\u0080\7\'\2\2v\u0080\7(\2\2wx\7)\2\2xy\7\61\2\2y\u0080")
        buf.write("\7*\2\2z{\7+\2\2{|\7\61\2\2|\u0080\7*\2\2}\u0080\7,\2")
        buf.write("\2~\u0080\7-\2\2\177r\3\2\2\2\177s\3\2\2\2\177t\3\2\2")
        buf.write("\2\177u\3\2\2\2\177v\3\2\2\2\177w\3\2\2\2\177z\3\2\2\2")
        buf.write("\177}\3\2\2\2\177~\3\2\2\2\u0080\27\3\2\2\2\u0081\u0082")
        buf.write("\b\r\1\2\u0082\u0083\7/\2\2\u0083\u008a\3\2\2\2\u0084")
        buf.write("\u0085\f\4\2\2\u0085\u0086\5\16\b\2\u0086\u0087\5\30\r")
        buf.write("\5\u0087\u0089\3\2\2\2\u0088\u0084\3\2\2\2\u0089\u008c")
        buf.write("\3\2\2\2\u008a\u0088\3\2\2\2\u008a\u008b\3\2\2\2\u008b")
        buf.write("\31\3\2\2\2\u008c\u008a\3\2\2\2\u008d\u008e\5\34\17\2")
        buf.write("\u008e\u008f\7\b\2\2\u008f\u0090\5\36\20\2\u0090\u0091")
        buf.write("\7\b\2\2\u0091\u0092\5 \21\2\u0092\u0093\7\b\2\2\u0093")
        buf.write("\u0094\5\"\22\2\u0094\u0095\7\b\2\2\u0095\u0096\5$\23")
        buf.write("\2\u0096\33\3\2\2\2\u0097\u0098\t\5\2\2\u0098\35\3\2\2")
        buf.write("\2\u0099\u009a\t\6\2\2\u009a\37\3\2\2\2\u009b\u009c\t")
        buf.write("\6\2\2\u009c!\3\2\2\2\u009d\u009e\t\7\2\2\u009e#\3\2\2")
        buf.write("\2\u009f\u00a0\t\5\2\2\u00a0%\3\2\2\2\n)CKX`o\177\u008a")
        return buf.getvalue()


class NMLCParser ( Parser ):

    grammarFileName = "NMLC.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "':'", "'('", "')'", "'=>'", "';'", "','", 
                     "'allow'", "'deny'", "'*'", "'or'", "'and'", "':%'", 
                     "'CHAREquals'", "'CHARNotEquals'", "'CHAREqualsIgnoreCase'", 
                     "'CHARNotEqualsIgnoreCase'", "'CHARLike'", "'CHARNotLike'", 
                     "'NumericEquals'", "'NumericNotEquals'", "'NumericLessThan'", 
                     "'NumericLessThanEquals'", "'NumericGreaterThan'", 
                     "'NumericGreaterThanEquals'", "'DateEquals'", "'DateNotEquals'", 
                     "'DateLessThan'", "'DateLessThanEquals'", "'DateGreaterThan'", 
                     "'DateGreaterThanEquals'", "'Bool'", "'IpAddress'", 
                     "'NotIpAddress'", "'acs:CurrentTime'", "'acs:SecureTransport'", 
                     "'acs:SourceIp'", "'acs:MFAPresent'", "'acs:PrincipalARN'", 
                     "'ecs:tag/<'", "'>'", "'rds:ResourceTag/<'", "'oss:Delimiter'", 
                     "'oss:Prefix'", "'null'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "ID", "INT", "FLOAT", "CHAR", "LINE_COMMENT", 
                      "COMMENT", "WS" ]

    RULE_prog = 0
    RULE_ruleLine = 1
    RULE_ruleID = 2
    RULE_subject = 3
    RULE_effect = 4
    RULE_roles = 5
    RULE_logicalOp = 6
    RULE_condition = 7
    RULE_condition_type = 8
    RULE_condition_map = 9
    RULE_condition_key = 10
    RULE_condition_value_list = 11
    RULE_objects = 12
    RULE_service = 13
    RULE_action = 14
    RULE_resource_type = 15
    RULE_resource = 16
    RULE_alias = 17

    ruleNames =  [ "prog", "ruleLine", "ruleID", "subject", "effect", "roles", 
                   "logicalOp", "condition", "condition_type", "condition_map", 
                   "condition_key", "condition_value_list", "objects", "service", 
                   "action", "resource_type", "resource", "alias" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    ID=45
    INT=46
    FLOAT=47
    CHAR=48
    LINE_COMMENT=49
    COMMENT=50
    WS=51

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleLine(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NMLCParser.RuleLineContext)
            else:
                return self.getTypedRuleContext(NMLCParser.RuleLineContext,i)


        def getRuleIndex(self):
            return NMLCParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = NMLCParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 36
                self.ruleLine()
                self.state = 39 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==NMLCParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleID(self):
            return self.getTypedRuleContext(NMLCParser.RuleIDContext,0)


        def subject(self):
            return self.getTypedRuleContext(NMLCParser.SubjectContext,0)


        def objects(self):
            return self.getTypedRuleContext(NMLCParser.ObjectsContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_ruleLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLine" ):
                listener.enterRuleLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLine" ):
                listener.exitRuleLine(self)




    def ruleLine(self):

        localctx = NMLCParser.RuleLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_ruleLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self.ruleID()
            self.state = 42
            self.match(NMLCParser.T__0)
            self.state = 43
            self.match(NMLCParser.T__1)
            self.state = 44
            self.subject()
            self.state = 45
            self.match(NMLCParser.T__2)
            self.state = 46
            self.match(NMLCParser.T__3)
            self.state = 47
            self.match(NMLCParser.T__1)
            self.state = 48
            self.objects()
            self.state = 49
            self.match(NMLCParser.T__2)
            self.state = 50
            self.match(NMLCParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_ruleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleID" ):
                listener.enterRuleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleID" ):
                listener.exitRuleID(self)




    def ruleID(self):

        localctx = NMLCParser.RuleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ruleID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.match(NMLCParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def effect(self):
            return self.getTypedRuleContext(NMLCParser.EffectContext,0)


        def roles(self):
            return self.getTypedRuleContext(NMLCParser.RolesContext,0)


        def condition(self):
            return self.getTypedRuleContext(NMLCParser.ConditionContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_subject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubject" ):
                listener.enterSubject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubject" ):
                listener.exitSubject(self)




    def subject(self):

        localctx = NMLCParser.SubjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_subject)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.effect()
            self.state = 55
            self.match(NMLCParser.T__5)
            self.state = 56
            self.roles(0)
            self.state = 57
            self.match(NMLCParser.T__5)
            self.state = 58
            self.condition(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EffectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return NMLCParser.RULE_effect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffect" ):
                listener.enterEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffect" ):
                listener.exitEffect(self)




    def effect(self):

        localctx = NMLCParser.EffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_effect)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            _la = self._input.LA(1)
            if not(_la==NMLCParser.T__6 or _la==NMLCParser.T__7):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def roles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NMLCParser.RolesContext)
            else:
                return self.getTypedRuleContext(NMLCParser.RolesContext,i)


        def logicalOp(self):
            return self.getTypedRuleContext(NMLCParser.LogicalOpContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)



    def roles(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NMLCParser.RolesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_roles, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NMLCParser.T__8]:
                self.state = 63
                self.match(NMLCParser.T__8)
                pass
            elif token in [NMLCParser.ID]:
                self.state = 64
                self.match(NMLCParser.ID)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 73
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NMLCParser.RolesContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_roles)
                    self.state = 67
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                    self.state = 68
                    self.logicalOp()
                    self.state = 69
                    self.roles(4) 
                self.state = 75
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class LogicalOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return NMLCParser.RULE_logicalOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOp" ):
                listener.enterLogicalOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOp" ):
                listener.exitLogicalOp(self)




    def logicalOp(self):

        localctx = NMLCParser.LogicalOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_logicalOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            _la = self._input.LA(1)
            if not(_la==NMLCParser.T__9 or _la==NMLCParser.T__10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition_type(self):
            return self.getTypedRuleContext(NMLCParser.Condition_typeContext,0)


        def condition_map(self):
            return self.getTypedRuleContext(NMLCParser.Condition_mapContext,0)


        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(NMLCParser.ID)
            else:
                return self.getToken(NMLCParser.ID, i)

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NMLCParser.ConditionContext)
            else:
                return self.getTypedRuleContext(NMLCParser.ConditionContext,i)


        def logicalOp(self):
            return self.getTypedRuleContext(NMLCParser.LogicalOpContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)



    def condition(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NMLCParser.ConditionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_condition, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NMLCParser.T__8]:
                self.state = 79
                self.match(NMLCParser.T__8)
                pass
            elif token in [NMLCParser.T__12, NMLCParser.T__13, NMLCParser.T__14, NMLCParser.T__15, NMLCParser.T__16, NMLCParser.T__17, NMLCParser.T__18, NMLCParser.T__19, NMLCParser.T__20, NMLCParser.T__21, NMLCParser.T__22, NMLCParser.T__23, NMLCParser.T__24, NMLCParser.T__25, NMLCParser.T__26, NMLCParser.T__27, NMLCParser.T__28, NMLCParser.T__29, NMLCParser.T__30, NMLCParser.T__31, NMLCParser.T__32]:
                self.state = 80
                self.condition_type()
                self.state = 81
                self.condition_map(0)
                pass
            elif token in [NMLCParser.ID]:
                self.state = 83
                self.match(NMLCParser.ID)
                self.state = 84
                self.match(NMLCParser.T__11)
                self.state = 85
                self.match(NMLCParser.ID)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 94
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NMLCParser.ConditionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_condition)
                    self.state = 88
                    if not self.precpred(self._ctx, 4):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                    self.state = 89
                    self.logicalOp()
                    self.state = 90
                    self.condition(5) 
                self.state = 96
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Condition_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return NMLCParser.RULE_condition_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition_type" ):
                listener.enterCondition_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition_type" ):
                listener.exitCondition_type(self)




    def condition_type(self):

        localctx = NMLCParser.Condition_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_condition_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NMLCParser.T__12) | (1 << NMLCParser.T__13) | (1 << NMLCParser.T__14) | (1 << NMLCParser.T__15) | (1 << NMLCParser.T__16) | (1 << NMLCParser.T__17) | (1 << NMLCParser.T__18) | (1 << NMLCParser.T__19) | (1 << NMLCParser.T__20) | (1 << NMLCParser.T__21) | (1 << NMLCParser.T__22) | (1 << NMLCParser.T__23) | (1 << NMLCParser.T__24) | (1 << NMLCParser.T__25) | (1 << NMLCParser.T__26) | (1 << NMLCParser.T__27) | (1 << NMLCParser.T__28) | (1 << NMLCParser.T__29) | (1 << NMLCParser.T__30) | (1 << NMLCParser.T__31) | (1 << NMLCParser.T__32))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Condition_mapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition_key(self):
            return self.getTypedRuleContext(NMLCParser.Condition_keyContext,0)


        def condition_value_list(self):
            return self.getTypedRuleContext(NMLCParser.Condition_value_listContext,0)


        def condition_map(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NMLCParser.Condition_mapContext)
            else:
                return self.getTypedRuleContext(NMLCParser.Condition_mapContext,i)


        def logicalOp(self):
            return self.getTypedRuleContext(NMLCParser.LogicalOpContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_condition_map

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition_map" ):
                listener.enterCondition_map(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition_map" ):
                listener.exitCondition_map(self)



    def condition_map(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NMLCParser.Condition_mapContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 18
        self.enterRecursionRule(localctx, 18, self.RULE_condition_map, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.condition_key()
            self.state = 101
            self.condition_value_list(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 109
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NMLCParser.Condition_mapContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_condition_map)
                    self.state = 103
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 104
                    self.logicalOp()
                    self.state = 105
                    self.condition_map(3) 
                self.state = 111
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Condition_keyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(NMLCParser.FLOAT, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_condition_key

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition_key" ):
                listener.enterCondition_key(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition_key" ):
                listener.exitCondition_key(self)




    def condition_key(self):

        localctx = NMLCParser.Condition_keyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_condition_key)
        try:
            self.state = 125
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NMLCParser.T__33]:
                self.enterOuterAlt(localctx, 1)
                self.state = 112
                self.match(NMLCParser.T__33)
                pass
            elif token in [NMLCParser.T__34]:
                self.enterOuterAlt(localctx, 2)
                self.state = 113
                self.match(NMLCParser.T__34)
                pass
            elif token in [NMLCParser.T__35]:
                self.enterOuterAlt(localctx, 3)
                self.state = 114
                self.match(NMLCParser.T__35)
                pass
            elif token in [NMLCParser.T__36]:
                self.enterOuterAlt(localctx, 4)
                self.state = 115
                self.match(NMLCParser.T__36)
                pass
            elif token in [NMLCParser.T__37]:
                self.enterOuterAlt(localctx, 5)
                self.state = 116
                self.match(NMLCParser.T__37)
                pass
            elif token in [NMLCParser.T__38]:
                self.enterOuterAlt(localctx, 6)
                self.state = 117
                self.match(NMLCParser.T__38)
                self.state = 118
                self.match(NMLCParser.FLOAT)
                self.state = 119
                self.match(NMLCParser.T__39)
                pass
            elif token in [NMLCParser.T__40]:
                self.enterOuterAlt(localctx, 7)
                self.state = 120
                self.match(NMLCParser.T__40)
                self.state = 121
                self.match(NMLCParser.FLOAT)
                self.state = 122
                self.match(NMLCParser.T__39)
                pass
            elif token in [NMLCParser.T__41]:
                self.enterOuterAlt(localctx, 8)
                self.state = 123
                self.match(NMLCParser.T__41)
                pass
            elif token in [NMLCParser.T__42]:
                self.enterOuterAlt(localctx, 9)
                self.state = 124
                self.match(NMLCParser.T__42)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Condition_value_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def condition_value_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NMLCParser.Condition_value_listContext)
            else:
                return self.getTypedRuleContext(NMLCParser.Condition_value_listContext,i)


        def logicalOp(self):
            return self.getTypedRuleContext(NMLCParser.LogicalOpContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_condition_value_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition_value_list" ):
                listener.enterCondition_value_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition_value_list" ):
                listener.exitCondition_value_list(self)



    def condition_value_list(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NMLCParser.Condition_value_listContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 22
        self.enterRecursionRule(localctx, 22, self.RULE_condition_value_list, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(NMLCParser.ID)
            self._ctx.stop = self._input.LT(-1)
            self.state = 136
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NMLCParser.Condition_value_listContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_condition_value_list)
                    self.state = 130
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 131
                    self.logicalOp()
                    self.state = 132
                    self.condition_value_list(3) 
                self.state = 138
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ObjectsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def service(self):
            return self.getTypedRuleContext(NMLCParser.ServiceContext,0)


        def action(self):
            return self.getTypedRuleContext(NMLCParser.ActionContext,0)


        def resource_type(self):
            return self.getTypedRuleContext(NMLCParser.Resource_typeContext,0)


        def resource(self):
            return self.getTypedRuleContext(NMLCParser.ResourceContext,0)


        def alias(self):
            return self.getTypedRuleContext(NMLCParser.AliasContext,0)


        def getRuleIndex(self):
            return NMLCParser.RULE_objects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjects" ):
                listener.enterObjects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjects" ):
                listener.exitObjects(self)




    def objects(self):

        localctx = NMLCParser.ObjectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_objects)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.service()
            self.state = 140
            self.match(NMLCParser.T__5)
            self.state = 141
            self.action()
            self.state = 142
            self.match(NMLCParser.T__5)
            self.state = 143
            self.resource_type()
            self.state = 144
            self.match(NMLCParser.T__5)
            self.state = 145
            self.resource()
            self.state = 146
            self.match(NMLCParser.T__5)
            self.state = 147
            self.alias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServiceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_service

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterService" ):
                listener.enterService(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitService" ):
                listener.exitService(self)




    def service(self):

        localctx = NMLCParser.ServiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_service)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            _la = self._input.LA(1)
            if not(_la==NMLCParser.T__43 or _la==NMLCParser.ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = NMLCParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            _la = self._input.LA(1)
            if not(_la==NMLCParser.T__8 or _la==NMLCParser.ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Resource_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_resource_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResource_type" ):
                listener.enterResource_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResource_type" ):
                listener.exitResource_type(self)




    def resource_type(self):

        localctx = NMLCParser.Resource_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_resource_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            _la = self._input.LA(1)
            if not(_la==NMLCParser.T__8 or _la==NMLCParser.ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_resource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResource" ):
                listener.enterResource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResource" ):
                listener.exitResource(self)




    def resource(self):

        localctx = NMLCParser.ResourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_resource)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NMLCParser.T__8) | (1 << NMLCParser.T__43) | (1 << NMLCParser.ID))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(NMLCParser.ID, 0)

        def getRuleIndex(self):
            return NMLCParser.RULE_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias" ):
                listener.enterAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias" ):
                listener.exitAlias(self)




    def alias(self):

        localctx = NMLCParser.AliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_alias)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            _la = self._input.LA(1)
            if not(_la==NMLCParser.T__43 or _la==NMLCParser.ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[5] = self.roles_sempred
        self._predicates[7] = self.condition_sempred
        self._predicates[9] = self.condition_map_sempred
        self._predicates[11] = self.condition_value_list_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def roles_sempred(self, localctx:RolesContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

    def condition_sempred(self, localctx:ConditionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

    def condition_map_sempred(self, localctx:Condition_mapContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

    def condition_value_list_sempred(self, localctx:Condition_value_listContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         




